http://www.pcmag.com/article2/0,2817,764194,00.asp

Sometimes the keys on your keyboard just aren't in the right place. Many of us familiar with the original 84-key IBM PC keyboard layout have ingrained in our muscle memories that the Ctrl key is next to the A key. But most newer 102-key keyboards reverse the positions of the Caps Lock and Ctrl keys from where they originally were, which drives us crazy. We find ourselves toggling Caps Lock on and off instead of typing the intended combination of Ctrl and some other key. Some people prefer a keyboard laid out more like that of a typewriter, with Caps Lock at the bottom, Shift above, and Ctrl above that. Maybe you want to disable that pesky left Windows key, because you keep hitting it by mistake when you want the left Alt key.

This issue's utility gives you the keyboard of your dreams. TradeKeys 2 lets you map your keyboard almost any way you want. Under Windows 95, 98, and Me, you can change, swap, or disable any of the standard keys (those that existed on the original 84-key keyboard layout). Under Windows 2000 and XP, you can also remap extended keys such as Right Ctrl and Right Alt, the Windows logo key, and the navigation cluster. You can save your mappings to a file for reloading later. This lets different users on a system switch quickly between different mappings.

TradeKeys 2 is an update of our earlier keyboard mapping utility, ZDKeyMap. In addition to supporting NT-based operating systems, this new version offers an improved interface. We provide the Microsoft Visual C source code for TradeKeys with the utility for those interested in seeing how the program works. Note that PC Magazine programs are copyrighted and cannot be distributed, whether modified or unmodified. Use is subject to the terms and conditions of the license agreement distributed with the programs.

TradeKeys 2 runs on Windows 95, 98, Me, 2000, and XP. (Windows NT 4.0 is not supported.) To install the program, unzip the files to the folder of your choice, then run the Setup utility and follow the prompts. You can uninstall TradeKeys 2 using Control Panel | Add/Remove Programs.

Note that under Windows 9x, TradeKeys 2 uses the ZDKeyMap engine to remap the keyboard. But whereas ZDKeyMap attached itself to the Keyboard applet in Control Panel, TradeKeys 2 runs as a standalone application. If you already have ZDKeyMap installed, TradeKeys 2 can coexist with it, and you can use either program to change your keyboard mappings. If you uninstall either program, however, you'll have to reinstall the other, because the uninstaller will remove the file Vkeymap.vxd, which is used by both programs.

The main window ( Figure 1 ) contains all of the controls you need to use the program. The Mapped keys list on the left shows you which keys have been (or will be) remapped. Note: Under Windows 2000 and XP, you must reboot your computer before the remapping takes effect. Thus, when you first launch TradeKeys 2 under Windows 9x, the Mapped keys list shows the mappings that are currently in effect on your system, but under Windows 2000 and XP, the list shows the key mappings currently stored in the Registry. Whether these mappings are actually in effect depends on whether the system has been restarted since you specified the mappings.

The Mapped keys list is always sorted alphabetically by name, with swapped keys grouped together, and it uses colors and icons to indicate how each key is mapped. Any key not shown in the Keys column of this list will retain its normal function. If a key has been mapped to another key, it is shown in green with a green arrow icon. If a key is disabled, it is displayed in red with a red slashed-circle icon. If two keys have been swapped, they are grouped together in the list with a pair of blue arrow icons.

On the right side of the dialog, the Map from and Map to lists show all of the keys that can be remapped on your system, listed in the order that they're most likely to be remapped. The colors in these lists match the colors in the Mapped keys list, so you can see at a glance which keys have been mapped, swapped, or disabled. As a convenience, the selections in the Map from and Map to lists will change to match your selection in the Mapped keys list.

To add or change a key mapping, select the key you want remapped in the Map from list, select the key you want it mapped to in the Map to list, then click the Map, Swap, or Disable button. Clicking Map maps the first key to the second. Clicking Swap also maps the second key back to the first. Note that there is nothing special about swapped keys. All key mappings work independently; they don't chain from one to another. The Swap button just saves you the effort of mapping both halves of a swapped pair manually.

Clicking the Disable button disables whichever key is selected in the Map from list. In that case, your selection in the Map to list is irrelevant. You can also disable a key by selecting the special <Disabled> entry at the top of the Map to list and clicking the Map button. Note that when you disable a key, it does nothing at all when pressed; the system behaves as if the key doesn't exist. Therefore, if you don't map another key back to the one you disabled, you lose whatever function the disabled key served. For example, if you disable both Alt keys and don't map any other key to either Alt key, you have no way to generate any key combinations that include Alt.

As you make your choices with the Map from and Map to lists and the Map, Swap, and Disable buttons, the Mapped keys lists updates itself automatically. Each key on the keyboard can be mapped only once, so entries will be either added to the list or updated as appropriate. The list automatically sorts itself alphabetically by key name, except that swapped keys will be grouped together on consecutive lines to make them easier to see.

To restore any number of keys to their normal function, select their entries in the Mapped keys list and click the Unmap button. To restore your entire keyboard to normal operation, unmap all entries. You can select all of them at once by tabbing to or clicking on the list and pressing Ctrl-A. If you have more than one item selected, TradeKeys 2 will request confirmation before it deletes anything. You can also unmap a key by selecting the same key in both the Map from and Map to lists, then clicking the Map button. Mapping a key to itself restores its normal function, so it will be removed from the list. If that key was one half of a swapped pair, the other half of the pair remains mapped and its color and icon will be updated accordingly. The same applies if you disable one key in a swapped pair.

Once the Mapped keys list shows the mappings you want, you can put them into effect by clicking the OK button. Under Windows 9x, your new mappings take effect immediately, so TradeKeys 2 will close with no further prompting. Under Windows 2000 and XP, you have to restart the system. TradeKeys 2 will remind you of this when you click the OK button. If you don't wish to be reminded, check the Don't show me this again box before clicking OK to acknowledge the reminder.

Key mappings affect all users, so different users may wish to use different maps. TradeKeys 2 lets you save your keyboard maps so you can switch among different configurations easily ( Figure 2 ).

Clicking the Save button launches the Save keyboard map dialog. Enter the name you want for the file, then click the Save button or press Enter. The Save keyboard map dialog defaults to the program's home folder initially, but you can save a map in any folder you like. Once you do save a map to a different folder, TradeKeys 2 will remember that location for subsequent loads and saves. The resulting file will contain all mappings displayed in the Mapped keys list, whether or not you have actually put them into effect. You can also save an empty list if you want, creating a file that will restore your entire keyboard to normal operation once you have loaded the file and applied it.

To load a map from disk, use the Load button. Again, you can load a file from any folder you like, and TradeKeys 2 remembers that location for subsequent loads and saves. You can also load a file by either double-clicking that file in Windows Explorer or launching a shortcut to that file from your Desktop or Start menu. If TradeKeys 2 is not running, it will launch with the specified file already loaded. If the utility is already running, it will load the file just as if you had clicked the Load button and selected the desired file manually.

Regardless of the method you use, loading a file causes TradeKeys 2 to discard the current mappings from the Mapped keys list and replace them with the ones loaded from the file. To put the new mappings into effect, you must click the OK button. This allows you to review the contents of the file before activating it. Although applying the mappings immediately may seem more convenient (especially under Windows 9x, where a restart is not required), TradeKeys 2 does not provide this feature, because it may be applied maliciously.

TradeKeys Map files use a .tkm extension, and they are interchangeable among systems, with only one limitation. Under Windows 2000 and XP, TradeKeys 2 can remap extended keys. It cannot do this under Windows 9x. Therefore, if you load a file that was saved from Windows 2000 or XP onto a Win 9x system, TradeKeys 2 will discard any mappings that your system does not support and display a message to let you know that it did not load the entire file. This will not affect the contents of the file itself, unless you use the Save command to overwrite the original.

TradeKeys 2 was written using Microsoft Visual C++ 6.0. The Vkeymap.vxd virtual device driver was written by Zan Oliphant using a combination of assembler and C, and it requires the Windows 95 (or 98) Device Driver Kit to compile. I added support for Windows 2000 and XP through the Windows Scan Code Mapper feature. In the following sections, I'll describe how each of these work, and how the two were combined into one cross-platform program.

Under Windows 9x, TradeKeys 2 relies on a static virtual device driver, Vkeymap.vxd, that hooks into the keyboard device chain. This driver monitors and changes the scan codes sent by the keyboard as you press and release keys. It handles three system messages, Device_Init, Device_Init_Complete, and W32_DeviceIOControl.

The Device_Init message is sent when the VxD is first loaded during system start-up, and the message is handled by the OnDeviceInit function (Vkeymap.c). This function first checks the fLoaded flag. If this flag is TRUE, the driver is already loaded, so OnDeviceInit returns FALSE to prevent the driver from being loaded more than once. If not, OnDeviceInit queries the Registry to determine whether the key mapping data that is stored by the user interface is present in the Registry. If that data is present and can be read from the Registry, the data is copied to local storage (the KeyMappings array) and the fMappingOK flag is set to TRUE. Otherwise, the fMappingOK flag is set to FALSE. In that case, the driver will remain loaded but will not try to remap any keys. Finally, OnDeviceInit sets the fLoaded flag to TRUE and returns TRUE to signal the system to continue loading the driver.

Because each scan code is only one byte, there are only 256 possible scan codes. The lookup table, KeyMappings, is an array of 256 bytes. Each entry in the table represents one scan code, and each entry contains either the key's own scan code, the code of the key to which it will be mapped, or 0, to indicate that the key is disabled.

If OnDeviceInit returns TRUE, the system sends the Device_Init_Complete message, which is handled by the OnInitComplete function (see Vkeymap.c). This in turn calls Hook_Keyboard (Devdecl.asm), which hooks the driver into the keyboard chain. From then on, the C_KeyboardFilter function (Vkeymap.c) is called whenever the system receives a scan code from the keyboard.

Things get a little tricky when we try to tackle extended keys. The keyboard is a serial device. Every time a key is pressed or released, it generates a series of one or more bytes, called scan codes, representing the key in use and whether it was pressed or released. Standard keys—the keys found on the original 84-key IBM-PC keyboard—generate only one scan code. Extended keys, such as the right Ctrl, right Alt, and the Windows logo key, generate two: a prefix (0xE0 or 0xE1) to indicate that this is an extended key, followed by a second code to indicate which key.

The driver can handle only one scan code at a time, passing the code along unmodified, changing it to a different code, or preventing the system from receiving that code at all. This is why it can't map extended keys. To map a standard key to an extended key, the driver would have to generate an extra code-the prefix that indicates an extended key. There's no way for it to feed that extra prefix code into the data stream.

To map an extended key to a standard key, the driver would have to prevent the system from seeing the extended-key prefix, and then provide the scan code for the desired standard key. Although the driver can prevent the system from seeing the extended key prefix code, it doesn't know which extended key was pressed until it receives the next scan code in the sequence. Thus, there's no way for the driver to know whether to discard the extended-key prefix until it's too late.

A similar problem arises when you try to map one extended key to another. Different extended keys generate different prefixes, so the driver may have to modify both the prefix and the subsequent scan code. Again, until the driver receives the second scan code, it doesn't know which key is being pressed. By that time, it's too late to modify the prefix.

So, all that C_KeyboardFilter can do is pass extended key scan codes along unmodified. To do this, it uses a flag, fLastExtended. Whenever it sees the 0xE0 or 0xE1 prefix codes, it sets fLastExtended to TRUE, then passes the prefix along. When C_KeyboardFilter receives the next scan code, it sees that fLastExtended is set, clears it to FALSE, and passes that second scan code along unmodified. Similarly, if fLastExtended is not set when a scan code arrives, C_KeyboardFilter knows that the scan code represents a standard key. It looks up the corresponding scan code in the KeyMappings table and passes it along to the rest of the system.

The final message, W32_DeviceIOControl, allows applications to communicate with the driver. This message is handled by the OnDeviceIOControl function (found in Vkeymap.c). When an application wants to change the keyboard mappings, it obtains a handle to the driver and uses the DeviceIoControl API function to send the driver the IOCTL_NEW_MAPPINGS message (declared in TradeKeys.h) and a pointer to a 256-byte table containing the mappings to be applied. When OnDeviceIOControl detects this message, it copies the new table to local storage. Thus, the new mappings take effect immediately, without having to restart the system.

Win2000 and XP Support

With Windows 2000, Microsoft introduced a feature called the Windows Scan Code Mapper. You can read about it on Microsoft's Web site at www.microsoft.com/hwdev/tech/input/w2kscan-map.asp. TradeKeys 2 uses this feature to add keyboard mapping support to Windows 2000 and XP. Windows NT 4.0 isn't supported, because it doesn't offer this feature.

The Windows Scan Code Mapper uses data stored in the Registry at HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout, in a binary value named ScanCode Map, organized as a series of DWORD values. The first two DWORDs contain flag and version information. Under all current versions, these first two DWORDs are always zero. The rest of the data is an array of DWORDs. The first value is a count, indicating the number of DWORDs that follow. Each of the remaining DWORDs represents one key mapping, and the system uses the values as a lookup table. In each DWORD, the upper WORD contains the scan code of the key to be mapped, and the lower WORD contains either the scan code of the key to which it will be mapped, or zero, if the key is to be disabled. The last DWORD in the array must be zero. Note that the count includes this terminating zero.

While this sounds similar to the mechanism that Vkeymap.vxd uses under Windows 9x, it's not exactly the same. The important difference is that the mapping takes place after the system has already processed the keyboard's raw data stream, converting the varying-length series of scan codes that represent each keystroke to a single WORD value. For normal keys, the upper BYTE of that WORD is zero and the lower BYTE is that key's scan code as produced by the keyboard. For extended keys, the upper BYTE contains the prefix scan code (0xE0 or 0xE1) and the lower BYTE contains the second scan code for that key.

So, Windows 2000 and XP users can remap their keyboards any time they want just by placing the appropriate data into the Registry and restarting the system. However, this requires intimate knowledge of Registry editing and of the scan codes for each key on the keyboard. Any mistakes here could be disastrous. TradeKeys 2 takes care of the remapping tasks for you.

Tying it All Together

I built TradeKeys 2 as a standard dialog-based application using the MFC AppWizard. The key to the program's design lies in organizing the data so I can present a user interface that looks the same and works consistently regardless of the platform.

To do this, I use two arrays. The first is a global array, g_MasterTable, which holds basic information required about the keyboard itself. This is an array of MASTER_TABLE_ENTRY structures (declared in TradeKeys.h)—one for each key that TradeKeys 2 can map. Each structure contains two members. The wScanCode member is a WORD containing the scan code for the key, and the pszName member is a pointer to a string containing the name of the key.

The second array is a member of the CTradeKeysDlg class (see TradeKeysDlg.h and TradeKeysDlg.cpp), m_pMapArray, used to manage individual key mappings. This is a dynamically-allocated array of MAP_ARRAY_ENTRY structures (declared in TradeKeys.h), each containing five members. The wOldCode and wNewCode members are WORDs, containing the scan code of the key to be mapped and the key it is mapped to, respectively. The iColor member is an integer that determines the icons and colors used to display each key in the lists. The last two members, pszOldName and pszNewName, are pointers to strings containing the names of the old and new keys, allowing the list control to use a callback function to display the names and simplifying the CTradeKeysDlg::Compare_Old_Key_Names function (see TradeKeysDlg.cpp) used to sort the array by key name.

At start-up, the CTradeKeysDlg::OnInitDialog function (TradeKeysDlg.cpp) checks the operating system version, setting the g_bIsNT flag to TRUE if it's running under Windows NT. The function then walks through the g_MasterTable array to build the Map from and Map to lists. If the g_bIsNT flag is not set, the function skips over the extended key entries in the table, so the lists don't include extended keys when the program is running under Win9x.

Next, OnInitDialog calls the CTradeKeysDlg::Read_Map_Data function. Read_Map_Data checks the g_bIsNT flag, then reads the appropriate mapping data for the current platform from the Registry. For Windows NT, Read_Map_Data performs several checks on the data to ensure that it is in the correct format. For Windows 9x, Read_Map_Data simply ensures that the data consists of 256 bytes. Having read the data successfully, Read_Map_Data builds m_pMapArray to contain one element for each mapped key, making sure that each element contains valid scan codes. The return value from Read_Map_Data tells OnInitDialog whether or not Read_Map_Data succeeded and if not, which error message to display before exiting the program.

Once the mapping data has been read successfully, OnInitDialog calls the CTradeKeysDlg::Arrange_Array function. This is responsible for organizing the list to make it easier to read. First, Arrange_Array calls the qsort library function to sort the array alphabetically by key name. Arrange_Array makes a second pass through the array, rearranging the elements to group swapped keys together and setting the iColor member of each element so that the list controls can display each key with the appropriate color and icon. After Arrange_Array returns, OnInitDialog builds the Mapped keys list, adding one item to the m_lstKeys list control for each element in the array.

The rest of the program handles the user interface, adding, removing, or updating elements in m_pMapArray as the user maps, remaps, and unmaps keys. When the user clicks the OK button to apply the desired mappings, the CTradeKeysDlg::OnOK handler takes over. OnOK starts by checking the g_bIsNT flag. If the flag is set and the user has changed any mappings since the program was started, OnOK reads through the mapping array and uses the array to build the list of DWORDs for the Windows Scan Code Mapper. After writing that data to the Registry, OnOK prompts the user to restart the system, then terminates the program.

If the g_bIsNT flag is not set, OnOK builds the global g_KeyMappings array and writes it to the Registry, so the Vkeymap.vxd device driver can load the array next time the system is started. OnOK then calls the CTradeKeysDlg::Write_Driver function to pass the new mappings to the device driver, so they take effect immediately.

It's usually the more sophisticated users who want to remap their keyboards, because these are the people who've been using computers so long that they remember the original IBM-PC keyboard. These more sophisticated users are also more likely to be using NT-based operating systems, so NT support was highly desirable. With the Windows Scan Code Mapper, TradeKeys 2 was able to support keyboard remapping under Windows 2000 and XP.

Gregory A. Wolking, the author of TradeKeys 2, is a sysop in the PC Magazine Utilities Support forum and a frequent contributor to PC Magazine. Sheryl Canter is the editor of the Utilities column and a contributing editor of PC Magazine.

